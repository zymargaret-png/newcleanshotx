<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loom Pro Crop (è™šæ‹Ÿè£åˆ‡ç‰ˆ)</title>
    <style>
        :root {
            --bg-gradient: radial-gradient(circle at 50% -20%, #1a1a1a, #000000);
            --glass-bg: rgba(40, 40, 40, 0.8);
            --accent: #0A84FF; --danger: #FF453A; --text: #FFF;
        }
        * { box-sizing: border-box; user-select: none; }
        body {
            background: var(--bg-gradient); color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; margin: 0; overflow: hidden;
        }

        /* --- é¡¶éƒ¨æ§åˆ¶æ  --- */
        .dock {
            position: absolute; top: 20px; z-index: 100;
            display: flex; align-items: center; gap: 10px; padding: 8px 16px;
            background: var(--glass-bg); backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 50px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transition: transform 0.3s;
        }
        
        .divider { width: 1px; height: 16px; background: rgba(255,255,255,0.2); }

        button, select {
            background: transparent; border: none; color: #ddd; font-size: 13px;
            padding: 6px 12px; border-radius: 8px; cursor: pointer; font-weight: 500;
            display: flex; align-items: center; gap: 5px; transition: 0.2s;
        }
        button:hover { background: rgba(255,255,255,0.1); color: #fff; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }

        /* ä¸‹æ‹‰èœå• */
        .select-wrap { position: relative; }
        select { appearance: none; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); padding-right: 24px; outline: none;}
        .arrow { position: absolute; right: 8px; top: 50%; transform: translateY(-50%); font-size: 10px; pointer-events: none; color: #aaa; }

        .btn-primary { background: var(--accent) !important; color: #fff !important; }
        .btn-record { background: rgba(255,69,58,0.15) !important; color: var(--danger) !important; }
        .btn-record:hover { background: var(--danger) !important; color: #fff !important; }
        
        /* çŠ¶æ€åˆ‡æ¢ */
        .btn-toggle.active { background: #fff !important; color: #000 !important; }
        body.recording .dock { transform: translateY(-200%); }

        /* --- ç”»å¸ƒåŒºåŸŸ --- */
        .viewport {
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            padding: 40px;
        }

        .canvas-box {
            position: relative; 
            /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œè®©9:16èƒ½å®Œæ•´æ˜¾ç¤º */
            max-height: 85vh; max-width: 90vw;
            background: #000; 
            border: 2px solid #333; 
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            overflow: hidden;
            cursor: grab; /* æç¤ºå¯æ‹–æ‹½ */
            transition: border-color 0.3s;
        }
        .canvas-box:active { cursor: grabbing; border-color: var(--accent); }
        
        body.recording .canvas-box { border-color: var(--danger); }

        canvas { width: 100%; height: 100%; display: block; }

        /* æç¤ºå±‚ */
        .tip-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .grid-lines {
            position: absolute; inset: 0; opacity: 0; transition: opacity 0.3s;
            background-image: 
                linear-gradient(rgba(255,255,255,0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 1px);
            background-size: 33.3% 33.3%;
        }
        .canvas-box:active .grid-lines { opacity: 1; } /* æ‹–æ‹½æ—¶æ˜¾ç¤ºæ„å›¾è¾…åŠ©çº¿ */

        .drag-tip {
            margin-top: auto; margin-bottom: 20px;
            background: rgba(0,0,0,0.6); color: #fff; padding: 6px 12px; border-radius: 20px; font-size: 12px;
            backdrop-filter: blur(4px); opacity: 0.8;
        }

        .status-bar { position: fixed; bottom: 15px; font-size: 12px; color: #666; display: flex; gap: 10px;}
        .badge { padding: 2px 6px; border-radius: 4px; background: #222; border: 1px solid #333; }
        
        .hidden { display: none; }
    </style>
</head>
<body>

    <div class="dock">
        <button id="initBtn" class="btn-primary">ğŸ“¡ åˆå§‹åŒ–</button>
        <div class="divider"></div>
        
        <div class="select-wrap">
            <select id="ratioSelect">
                <option value="1.777">16:9 (ç”µè„‘å®½å±)</option>
                <option value="0.5625" selected>9:16 (æŠ–éŸ³/æ‰‹æœº)</option>
                <option value="0.75">3:4 (å°çº¢ä¹¦)</option>
                <option value="1">1:1 (æ–¹å½¢)</option>
            </select>
            <span class="arrow">â–¼</span>
        </div>

        <div class="divider"></div>
        <button id="camToggle" class="btn-toggle active">å¤´åƒ: å¼€</button>
        <button id="filterBtn" class="btn-toggle">ç¾é¢œ: å…³</button>
        <div class="divider"></div>
        <button id="recBtn" class="btn-record" disabled>ğŸ”´ å¼€å§‹å½•åˆ¶</button>
        <button id="stopBtn" style="display:none;">â¹ åœæ­¢</button>
    </div>

    <div class="viewport">
        <div id="canvasContainer" class="canvas-box" style="aspect-ratio: 9/16;">
            <canvas id="mainCanvas"></canvas>
            
            <div class="tip-layer">
                <div class="grid-lines"></div> <div id="countdown" style="font-size:100px; font-weight:800; display:none;">3</div>
                <div class="drag-tip">ğŸ‘† æŒ‰ä½ç”»é¢æ‹–æ‹½ä»¥è°ƒæ•´å½•åˆ¶åŒºåŸŸ</div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div id="formatTag" class="badge">æ£€æµ‹ä¸­...</div>
        <span id="statusText">ç­‰å¾…åˆå§‹åŒ–...</span>
    </div>

    <video id="vScreen" class="hidden" autoplay playsinline muted></video>
    <video id="vCam" class="hidden" autoplay playsinline muted></video>

    <script>
        const $ = id => document.getElementById(id);
        const canvas = $('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- æ ¸å¿ƒçŠ¶æ€ ---
        const state = {
            ready: false, recording: false,
            ratio: 0.5625, // é»˜è®¤ 9:16
            canvasW: 1080, canvasH: 1920, // è¾“å‡ºåˆ†è¾¨ç‡
            
            // å±å¹•è£åˆ‡å‚æ•° (æ ¸å¿ƒ)
            screenOffsetX: 0, 
            screenOffsetY: 0,
            
            // æ‘„åƒå¤´å‚æ•°
            camEnabled: true, filterMode: 0,
            camX: 50, camY: 1600, camSize: 300, // é»˜è®¤æ”¾ä¸‹é¢
            camDragging: false,
            
            // æ‹–æ‹½çŠ¶æ€
            isDraggingScreen: false,
            lastMouseX: 0, lastMouseY: 0,

            audioLevel: 0
        };
        
        let recorder, chunks = [], audioCtx, analyser, dataArray;

        // 1. æ ¼å¼æ£€æµ‹
        (function checkSupport() {
            const types = ['video/mp4;codecs=avc1', 'video/mp4', 'video/webm;codecs=vp9'];
            for(let t of types) {
                if(MediaRecorder.isTypeSupported(t)) {
                    state.mimeType = t; 
                    $('formatTag').innerText = t.includes('mp4') ? "MP4" : "WebM";
                    return;
                }
            }
            state.mimeType = 'video/webm'; // ä¿åº•
        })();

        // 2. æ¯”ä¾‹åˆ‡æ¢é€»è¾‘
        $('ratioSelect').onchange = (e) => {
            state.ratio = parseFloat(e.target.value);
            const box = $('canvasContainer');
            
            // è®¾å®šè¾“å‡ºç‰©ç†åˆ†è¾¨ç‡ (ä¿è¯æ¸…æ™°åº¦)
            if(state.ratio >= 1) { // æ¨ªå±
                state.canvasW = 1920; state.canvasH = 1920 / state.ratio;
            } else { // ç«–å±
                state.canvasW = 1080; state.canvasH = 1080 / state.ratio;
            }
            
            // æ›´æ–° Canvas
            canvas.width = state.canvasW;
            canvas.height = state.canvasH;
            box.style.aspectRatio = `${state.canvasW}/${state.canvasH}`;
            
            // é‡ç½®è£åˆ‡åç§»ï¼Œé˜²æ­¢ç”»é¢è·‘ä¸¢
            state.screenOffsetX = 0;
            state.screenOffsetY = 0;
            
            // é‡ç½®æ‘„åƒå¤´ä½ç½®åˆ°å³ä¸‹è§’
            state.camSize = state.canvasH * 0.18; // åŠ¨æ€å¤§å°
            state.camX = state.canvasW - state.camSize - 50;
            state.camY = state.canvasH - state.camSize - 50;

            $('statusText').innerText = `è¾“å‡ºåˆ†è¾¨ç‡: ${Math.round(state.canvasW)}x${Math.round(state.canvasH)}`;
        };
        // è§¦å‘ä¸€æ¬¡é»˜è®¤ 9:16
        $('ratioSelect').dispatchEvent(new Event('change'));

        // 3. åˆå§‹åŒ–
        $('initBtn').onclick = async () => {
            try {
                // âš ï¸ é‡ç‚¹ï¼šè¯·æ±‚å½•åˆ¶æ•´ä¸ªå±å¹•ï¼Œä¸è¦é€‰çª—å£
                const sStream = await navigator.mediaDevices.getDisplayMedia({ video: {width:1920, height:1080}, audio: true });
                $('vScreen').srcObject = sStream;
                
                const cStream = await navigator.mediaDevices.getUserMedia({ video: {width:1920, height:1080}, audio: true });
                $('vCam').srcObject = cStream;

                // éŸ³é¢‘
                audioCtx = new (window.AudioContext||window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(cStream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 32;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                state.ready = true;
                $('initBtn').style.display = 'none';
                $('recBtn').disabled = false;
                $('statusText').innerText = "è¯·é€‰æ‹©ã€æ•´ä¸ªå±å¹•ã€‘ä»¥è·å¾—æœ€ä½³è£åˆ‡æ•ˆæœ";
                
                loop();
            } catch(e) { alert(e.message); }
        };

        // 4. æ¸²æŸ“å¾ªç¯ (æ ¸å¿ƒè£åˆ‡é€»è¾‘)
        function loop() {
            requestAnimationFrame(loop);
            if(!state.ready) return;

            if(analyser) { analyser.getByteFrequencyData(dataArray); state.audioLevel = dataArray.reduce((a,b)=>a+b,0)/dataArray.length; }

            const W = state.canvasW;
            const H = state.canvasH;
            ctx.clearRect(0,0,W,H);
            ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H);

            const vScreen = $('vScreen');
            
            // --- A. ç»˜åˆ¶å±å¹• (Pan & Scan) ---
            if(vScreen.readyState === 4) {
                const vw = vScreen.videoWidth;
                const vh = vScreen.videoHeight;
                
                // ç­–ç•¥ï¼šCover (ç­‰æ¯”æ”¾å¤§å¡«æ»¡)
                // è®¡ç®—æ­¤æ—¶åº”è¯¥ç¼©æ”¾å¤šå°‘å€æ‰èƒ½å¡«æ»¡ç”»å¸ƒ
                const scale = Math.max(W / vw, H / vh);
                
                const drawW = vw * scale;
                const drawH = vh * scale;
                
                // é»˜è®¤å±…ä¸­ + åŠ ä¸Šç”¨æˆ·çš„åç§»é‡
                // é™åˆ¶æ‹–æ‹½èŒƒå›´ï¼šä¸è¦æŠŠç”»é¢æ‹–å‡ºé»‘è¾¹
                const minX = W - drawW; 
                const minY = H - drawH;
                
                // å±…ä¸­åŸºç¡€åæ ‡
                let x = (W - drawW) / 2 + state.screenOffsetX;
                let y = (H - drawH) / 2 + state.screenOffsetY;
                
                // è¾¹ç•Œé™åˆ¶ (Clamp)
                if(drawW > W) x = Math.max(minX, Math.min(0, x));
                if(drawH > H) y = Math.max(minY, Math.min(0, y));
                
                // æ›´æ–°å› stateï¼Œä¿è¯æ‰‹æ„Ÿ
                // æ³¨æ„ï¼šè¿™é‡Œä¸ºäº†æ‹–æ‹½é€»è¾‘ç®€å•ï¼Œå…ˆä¸å›å†™stateï¼Œä»…æ¸²æŸ“é™åˆ¶
                
                ctx.drawImage(vScreen, x, y, drawW, drawH);
            }

            // --- B. ç»˜åˆ¶æ‘„åƒå¤´ ---
            if(state.camEnabled && $('vCam').readyState === 4) {
                drawCam(ctx);
            }
        }

        function drawCam(ctx) {
            const { camX, camY, camSize, audioLevel, filterMode } = state;
            const r = camSize / 2;
            const cx = camX + r;
            const cy = camY + r;

            ctx.save();
            // å…‰åœˆ
            const vol = audioLevel / 40;
            if(vol > 0.1) {
                ctx.beginPath(); ctx.arc(cx, cy, r + vol*15, 0, Math.PI*2);
                ctx.fillStyle = `rgba(10, 132, 255, ${0.2+vol*0.2})`; ctx.fill();
            }
            // å‰ªåˆ‡
            ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 20; ctx.shadowOffsetY = 5;
            ctx.clip();

            // æ»¤é•œ
            if(filterMode === 1) ctx.filter = 'contrast(1.1) saturate(1.1)';
            
            const vCam = $('vCam');
            const min = Math.min(vCam.videoWidth, vCam.videoHeight);
            ctx.drawImage(vCam, (vCam.videoWidth-min)/2, (vCam.videoHeight-min)/2, min, min, camX, camY, camSize, camSize);
            
            ctx.filter = 'none';
            ctx.strokeStyle = "#fff"; ctx.lineWidth = camSize*0.03; ctx.stroke();
            ctx.restore();
        }

        // 5. äº¤äº’ï¼šæ‹–æ‹½å±å¹• & æ‘„åƒå¤´
        const box = $('canvasContainer');
        
        box.onmousedown = (e) => {
            const rect = box.getBoundingClientRect();
            // åæ ‡è½¬æ¢ï¼šDOMåæ ‡ -> ç”»å¸ƒåæ ‡
            const scaleX = state.canvasW / rect.width;
            const scaleY = state.canvasH / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            // æ£€æµ‹æ˜¯å¦ç‚¹ä¸­æ‘„åƒå¤´
            const cx = state.camX + state.camSize/2;
            const cy = state.camY + state.camSize/2;
            if(state.camEnabled && Math.hypot(mx-cx, my-cy) < state.camSize/2) {
                state.camDragging = true;
            } else {
                // æ²¡ç‚¹ä¸­æ‘„åƒå¤´ï¼Œé‚£å°±æ˜¯æ‹–æ‹½èƒŒæ™¯å±å¹•
                state.isDraggingScreen = true;
            }
            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;
        };

        window.onmousemove = (e) => {
            if(!state.camDragging && !state.isDraggingScreen) return;

            const rect = box.getBoundingClientRect();
            const scaleX = state.canvasW / rect.width; // ç‰©ç†åƒç´ /CSSåƒç´ 
            const scaleY = state.canvasH / rect.height;
            
            const dx = (e.clientX - state.lastMouseX) * scaleX;
            const dy = (e.clientY - state.lastMouseY) * scaleY;

            if(state.camDragging) {
                state.camX += dx; state.camY += dy;
            } else if (state.isDraggingScreen) {
                state.screenOffsetX += dx;
                state.screenOffsetY += dy;
            }

            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;
        };

        window.onmouseup = () => {
            state.camDragging = false;
            state.isDraggingScreen = false;
        };

        // 6. å½•åˆ¶é€»è¾‘ (ä¿æŒä¸å˜)
        $('recBtn').onclick = () => {
            $('dock').style.display = 'none'; // éšè—èœå•
            let c = 3; $('countdown').innerText = c; $('countdown').style.display = 'block';
            const t = setInterval(()=> {
                c--; if(c>0) $('countdown').innerText = c;
                else { clearInterval(t); $('countdown').style.display = 'none'; startRec(); }
            }, 1000);
        };
        
        function startRec() {
            chunks = [];
            const stream = canvas.captureStream(30); // 30FPS
            // åˆå¹¶éŸ³é¢‘
            const tracks = [];
            if($('vScreen').srcObject) tracks.push(...$('vScreen').srcObject.getAudioTracks());
            if($('vCam').srcObject) tracks.push(...$('vCam').srcObject.getAudioTracks());
            if(tracks.length) stream.addTrack(tracks[0]);
            
            recorder = new MediaRecorder(stream, {mimeType: state.mimeType, videoBitsPerSecond: 5000000});
            recorder.ondataavailable = e => { if(e.data.size) chunks.push(e.data); };
            recorder.onstop = () => {
                const blob = new Blob(chunks, {type: state.mimeType});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = `Crop_${state.canvasW}x${state.canvasH}_${Date.now()}.mp4`;
                a.click();
                document.body.classList.remove('recording');
            };
            recorder.start();
            document.body.classList.add('recording');
            $('recBtn').style.display = 'none';
            $('stopBtn').style.display = 'flex';
        }
        
        $('stopBtn').onclick = () => {
            recorder.stop();
            $('recBtn').style.display = 'flex';
            $('stopBtn').style.display = 'none';
        };

        // åŠŸèƒ½å¼€å…³
        $('camToggle').onclick = (e) => {
            state.camEnabled = !state.camEnabled;
            e.target.innerText = state.camEnabled ? "å¤´åƒ: å¼€" : "å¤´åƒ: å…³";
            e.target.classList.toggle('active');
        };
        $('filterBtn').onclick = (e) => {
            state.filterMode = state.filterMode ? 0 : 1;
            e.target.innerText = state.filterMode ? "ç¾é¢œ: å¼€" : "ç¾é¢œ: å…³";
            e.target.classList.toggle('active');
        };
        
        // åˆ«åé€‚é…
        if(!document.getElementById('dock')) document.querySelector('.dock').id = 'dock';

    </script>
</body>
</html>