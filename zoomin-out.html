<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loom Pro V12 (è‡ªåŠ¨ç”µå½±æ„Ÿç‰ˆ)</title>
    <style>
        :root { --bg: #0f1117; --text: #fff; --accent: #625DF5; --danger: #EF476F; --pink: #FF69B4; }
        body { background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; height: 100vh; margin: 0; overflow: hidden; user-select: none; }
        
        .controls { 
            background: rgba(30, 33, 45, 0.95); backdrop-filter: blur(10px);
            padding: 12px 20px; border-radius: 50px; margin-bottom: 15px; 
            display: flex; gap: 12px; align-items: center; border: 1px solid rgba(255,255,255,0.1); z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4); flex-wrap: wrap; justify-content: center;
        }
        button { padding: 8px 16px; border-radius: 20px; border: none; cursor: pointer; font-weight: 600; background: #333; color: #ccc; transition: 0.2s; font-size: 13px; white-space: nowrap;}
        button:hover { background: #444; color: #fff; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-primary { background: var(--accent); color: #fff; }
        .btn-record { background: var(--danger); color: #fff; box-shadow: 0 0 15px rgba(239, 71, 111, 0.3); }
        
        /* è‡ªåŠ¨è¿é•œæ¿€æ´»çŠ¶æ€ */
        .btn-auto.active { background: linear-gradient(45deg, #FF512F, #DD2476); color: white; box-shadow: 0 0 15px rgba(221, 36, 118, 0.4); border: none;}

        .viewport {
            position: relative; width: 90%; max-width: 1200px; aspect-ratio: 16/9;
            border-radius: 16px; overflow: hidden;
            box-shadow: 0 20px 80px rgba(0,0,0,0.6); border: 1px solid #333;
            cursor: default;
        }
        canvas { width: 100%; height: 100%; display: block; }
        
        .overlay-tip {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 20px;
            font-size: 12px; color: #ddd; pointer-events: none; border: 1px solid rgba(255,255,255,0.1);
        }
        .countdown { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 120px; font-weight: 900; pointer-events: none; text-shadow: 0 10px 30px rgba(0,0,0,0.6); }
        .hidden { display: none; }
        .hidden-stream { position: fixed; top:0; left:0; width:1px; height:1px; opacity:0; pointer-events:none; }
    </style>
</head>
<body>

    <div class="controls">
        <button id="initBtn" class="btn-primary">1. åˆå§‹åŒ–</button>
        <button id="requestMicBtn" style="margin-left:8px" title="å•ç‹¬è¯·æ±‚éº¦å…‹é£æƒé™">ğŸ”Š è¯·æ±‚éº¦å…‹é£æƒé™</button>
        <div style="width:1px;height:20px;background:#444"></div>
        <div id="messageArea" style="font-size:12px;color:#bbb;margin-left:10px;min-width:240px"></div>
        
        <button id="autoMoveBtn" class="btn-auto" disabled>ğŸ¬ è‡ªåŠ¨è¿é•œ: å…³</button>
        
        <button id="filterBtn" disabled>âœ¨ è´¨æ„Ÿ</button>
        <button id="pipBtn" disabled>ğŸ“º æ‚¬æµ®çª—</button>
        
        <div style="width:1px;height:20px;background:#444"></div>
        <button id="recBtn" class="btn-record" disabled>ğŸ”´ å½•åˆ¶MP4</button>
        <button id="stopBtn" disabled>â¹ åœæ­¢</button>
    </div>

    <div class="viewport" id="viewport">
        <canvas id="mainCanvas" width="1920" height="1080"></canvas>
        <div class="overlay-tip" id="statusTip">ğŸ’¡ å¼€å¯ã€è‡ªåŠ¨è¿é•œã€‘åï¼Œæ— éœ€æ“ä½œå³å¯è·å¾—é«˜çº§æ„Ÿ</div>
        <div id="countdown" class="countdown hidden">3</div>
    </div>

    <video id="vScreen" class="hidden-stream" autoplay playsinline muted></video>
    <video id="vCam" class="hidden-stream" autoplay playsinline muted></video>
    <canvas id="pipCanvas" width="320" height="320" class="hidden-stream"></canvas>
    <video id="vPip" class="hidden-stream" autoplay playsinline muted></video>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const pipCanvas = document.getElementById('pipCanvas');
        const pipCtx = pipCanvas.getContext('2d');
        
        const state = {
            ready: false, recording: false, bgMode: true, filterMode: 1,
            autoMove: false, // è‡ªåŠ¨è¿é•œå¼€å…³
            
            // æ‘„åƒæœºçŠ¶æ€
            camera: { zoom: 1, x: 0, y: 0 },
            
            // è‡ªåŠ¨è¿é•œçš„ç›®æ ‡ç‚¹ (ç”¨äºç¼“åŠ¨)
            autoTarget: { zoom: 1.05, x: 20, y: 20, timer: 0 },

            camUI: { x: 1650, y: 850, size: 220, audioLevel: 0 }
        };
        
        let recorder, chunks = [], audioCtx, analyser, dataArray;

        // 1. åˆå§‹åŒ–
        document.getElementById('initBtn').onclick = async () => {
            try {
                // Debug: show we're requesting permissions
                const messageArea = document.getElementById('messageArea');
                messageArea.innerText = 'æ­£åœ¨è¯·æ±‚éº¦å…‹é£è®¸å¯â€¦';
                console.log('Requesting microphone permission');

                // é¦–å…ˆè¯·æ±‚éº¦å…‹é£æƒé™ï¼ˆå•ç‹¬è¯·æ±‚æœ‰æ—¶ä¼šå¸®åŠ©æµè§ˆå™¨å¼¹å‡ºé€‰æ‹©éº¦å…‹é£çš„å¯¹è¯ï¼‰
                let micStream = null;
                try {
                    micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    messageArea.innerText = 'éº¦å…‹é£è®¸å¯å·²å…è®¸';
                    console.log('Microphone permission granted');
                } catch (micErr) {
                    console.warn('è¯·æ±‚éº¦å…‹é£å¤±è´¥', micErr);
                    messageArea.innerText = 'éº¦å…‹é£è®¸å¯è¢«æ‹’ç»æˆ–å¼‚å¸¸: ' + micErr.name;
                }

                // å…³é”®ï¼šcursor: 'always' ç¡®ä¿å½•åˆ¶é¼ æ ‡
                messageArea.innerText = 'æ­£åœ¨è¯·æ±‚å±å¹•å…±äº«è®¸å¯â€¦ï¼ˆè¯·åœ¨æµè§ˆå™¨å¼¹çª—ä¸­é€‰æ‹©å±å¹•å¹¶å‹¾é€‰â€œå…±äº«éŸ³é¢‘â€ï¼‰';
                console.log('Requesting display permission');
                const sStream = await navigator.mediaDevices.getDisplayMedia({ 
                    video: {width: 1920, height: 1080, frameRate: 60, cursor: 'always'}, audio: true 
                });
                document.getElementById('vScreen').srcObject = sStream;
                // å¦‚æœæ²¡æœ‰å…ˆæ‹¿åˆ°éº¦å…‹é£ï¼ˆmicStream ä¸ºç©ºï¼‰ï¼Œåœ¨æ­¤å¤„å†è·å–ä¸€æ¬¡éº¦å…‹é£æƒé™
                let cStream = null;
                if (micStream) cStream = micStream;
                else cStream = await navigator.mediaDevices.getUserMedia({ video: {width: {ideal:1920}, height: {ideal:1080}}, audio: true });
                document.getElementById('vCam').srcObject = cStream;

                audioCtx = new (window.AudioContext||window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(cStream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 32;
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                state.ready = true;
                document.getElementById('initBtn').disabled = true;
                document.getElementById('initBtn').innerText = "âœ… å°±ç»ª";
                document.getElementById('recBtn').disabled = false;
                document.getElementById('filterBtn').disabled = false;
                document.getElementById('pipBtn').disabled = false;
                document.getElementById('autoMoveBtn').disabled = false;
                
                loop();
                } catch(e) { 
                console.error('åˆå§‹åŒ–å¤±è´¥', e);
                const messageArea = document.getElementById('messageArea');
                messageArea.innerText = 'åˆå§‹åŒ–é”™è¯¯: ' + e.name + (e.message?(' â€” '+e.message):'');
                // Provide macOS permission hint when Screen Recording is blocked or NotAllowedError
                if (e.name === 'NotAllowedError' || e.name === 'NotFoundError') {
                    messageArea.innerText += '\næç¤º: è‹¥ä½ åœ¨ macOSï¼Œè¯·æ£€æŸ¥ "ç³»ç»Ÿåå¥½è®¾ç½® â†’ éšç§ä¸å®‰å…¨æ€§ â†’ å±å¹•å½•åƒ/éº¦å…‹é£" æ˜¯å¦å…è®¸æµè§ˆå™¨è®¿é—®ã€‚';
                }
                alert("åˆå§‹åŒ–é”™è¯¯: " + e.message);
            }
        };

        // å•ç‹¬è¯·æ±‚éº¦å…‹é£æƒé™ (æ˜¾å¼è§¦å‘) â€” æœ‰æ—¶èƒ½ç¡®ä¿æµè§ˆå™¨å¼¹å‡ºéº¦å…‹é£æƒé™é€‰æ‹©
        const requestMicBtn = document.getElementById('requestMicBtn');
        requestMicBtn.onclick = async () => {
            const messageArea = document.getElementById('messageArea');
            try {
                messageArea.innerText = 'æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™ â€” è¯·åœ¨æµè§ˆå™¨å¼¹çª—ä¸­å…è®¸è®¿é—®';
                console.log('Requesting microphone via requestMicBtn');
                await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                messageArea.innerText = 'éº¦å…‹é£æƒé™å·²å…è®¸';
            } catch (e) {
                messageArea.innerText = 'éº¦å…‹é£è¯·æ±‚å¤±è´¥: ' + (e.name || e.message);
                console.warn('Microphone request failed', e);
                if (e.name === 'NotAllowedError' || e.name === 'SecurityError') {
                    messageArea.innerText += '\nè¯·æ£€æŸ¥æµè§ˆå™¨æˆ–ç³»ç»Ÿæƒé™è®¾ç½®ï¼ˆChromeåœ°å€æ å³ä¾§çš„éº¦å…‹é£å›¾æ ‡ï¼Œæˆ– macOS ç³»ç»Ÿåå¥½è®¾ç½®/éšç§ï¼‰';
                }
            }
            // æ›´æ–°æƒé™çŠ¶æ€æ˜¾ç¤º
            updatePermissionStatus();
        };

        // æƒé™ API æ£€æŸ¥å’ŒçŠ¶æ€æ˜¾ç¤º
        async function updatePermissionStatus() {
            const messageArea = document.getElementById('messageArea');
            if (navigator.permissions && navigator.permissions.query) {
                try {
                    const status = await navigator.permissions.query({ name: 'microphone' });
                    messageArea.innerText = (messageArea.innerText?messageArea.innerText+'\n':'') + 'éº¦å…‹é£æƒé™çŠ¶æ€: ' + status.state;
                    status.onchange = () => { messageArea.innerText = 'éº¦å…‹é£æƒé™çŠ¶æ€: ' + status.state; };
                } catch(e) {
                    console.warn('Permissions API query failed', e);
                }
            } else {
                messageArea.innerText = (messageArea.innerText?messageArea.innerText+'\n':'') + 'æµè§ˆå™¨ä¸æ”¯æŒ Permissions APIï¼Œæ— æ³•æŸ¥è¯¢éº¦å…‹é£çŠ¶æ€';
            }
            // æ£€æŸ¥æ˜¯å¦æ˜¯å®‰å…¨ä¸Šä¸‹æ–‡
            if (!window.isSecureContext) {
                messageArea.innerText += '\næç¤º: é¡µé¢ä¸æ˜¯å®‰å…¨ä¸Šä¸‹æ–‡ (https æˆ– localhost)ï¼Œæµè§ˆå™¨å°†ä¸ä¼šæ˜¾ç¤ºæƒé™å¼¹çª—ã€‚è¯·é€šè¿‡ `npm run dev` åœ¨ localhost æˆ–éƒ¨ç½²åˆ° HTTPS ä¸‹è®¿é—®ã€‚';
            }
        }
        // åœ¨åŠ è½½æ—¶æ›´æ–°ä¸€æ¬¡
        updatePermissionStatus();

        // 2. æ¸²æŸ“å¾ªç¯
        function loop() {
            if(!state.ready) return requestAnimationFrame(loop);

            if(analyser) {
                analyser.getByteFrequencyData(dataArray);
                state.camUI.audioLevel = dataArray.reduce((a,b)=>a+b,0)/dataArray.length;
            }

            // --- ğŸ¬ æ ¸å¿ƒï¼šè‡ªåŠ¨è¿é•œé€»è¾‘ (Auto-Drift) ---
            if (state.autoMove) {
                state.autoTarget.timer++;
                // æ¯ 300 å¸§ (çº¦5ç§’) åˆ‡æ¢ä¸€æ¬¡å¾®å°çš„ç›®æ ‡ï¼Œåˆ¶é€ â€œå‘¼å¸æ„Ÿâ€
                if (state.autoTarget.timer > 300) {
                    state.autoTarget.timer = 0;
                    // éšæœºç¼©æ”¾ 1.02 ~ 1.10 (éå¸¸å¾®å¦™)
                    state.autoTarget.zoom = 1.02 + Math.random() * 0.08;
                    // éšæœºåç§» -30px ~ 30px
                    state.autoTarget.x = (Math.random() - 0.5) * 60;
                    state.autoTarget.y = (Math.random() - 0.5) * 60;
                }
                
                // ææ…¢é€Ÿç¼“åŠ¨ (0.005)ï¼Œæ¨¡æ‹Ÿç”µå½±å¹³æ»‘æ¨è½¨
                state.camera.zoom += (state.autoTarget.zoom - state.camera.zoom) * 0.005;
                state.camera.x += (state.autoTarget.x - state.camera.x) * 0.005;
                state.camera.y += (state.autoTarget.y - state.camera.y) * 0.005;
            } else {
                // å¦‚æœå…³é—­ï¼Œç¼“æ…¢å¤ä½
                state.camera.zoom += (1 - state.camera.zoom) * 0.05;
                state.camera.x += (0 - state.camera.x) * 0.05;
                state.camera.y += (0 - state.camera.y) * 0.05;
            }

            // èƒŒæ™¯
            const grad = ctx.createLinearGradient(0, 0, 1920, 1080);
            grad.addColorStop(0, "#2b32b2"); grad.addColorStop(1, "#1488cc");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 1920, 1080);

            // å±å¹•
            const vScreen = document.getElementById('vScreen');
            if (vScreen.readyState === 4) {
                ctx.save();
                const padding = 80; 
                const baseW = 1920 - (padding*2);
                const baseH = 1080 - (padding*2);
                
                ctx.translate(1920/2, 1080/2);
                ctx.scale(state.camera.zoom, state.camera.zoom);
                ctx.translate(-state.camera.x, -state.camera.y);

                ctx.shadowColor = "rgba(0,0,0,0.4)"; ctx.shadowBlur = 40; ctx.shadowOffsetY = 20;
                ctx.drawImage(vScreen, -baseW/2, -baseH/2, baseW, baseH);
                ctx.restore();
            }

            drawCamera(ctx, state.camUI.x, state.camUI.y, state.camUI.size, true);
            
            pipCtx.fillStyle = "#000"; pipCtx.fillRect(0,0,320,320);
            drawCamera(pipCtx, 160, 160, 280, false);

            requestAnimationFrame(loop);
        }

        function drawCamera(targetCtx, x, y, size, hasShadow) {
            const vCam = document.getElementById('vCam');
            if(vCam.readyState !== 4) return;
            const r = size/2;

            targetCtx.save();
            const vol = state.camUI.audioLevel / 40;
            if(vol > 0.1) {
                targetCtx.beginPath(); targetCtx.arc(x, y, r + vol*15, 0, Math.PI*2);
                targetCtx.fillStyle = `rgba(98, 93, 245, ${0.3 + vol*0.2})`; targetCtx.fill();
            }
            targetCtx.beginPath(); targetCtx.arc(x, y, r, 0, Math.PI*2);
            if(hasShadow) { targetCtx.shadowColor = "rgba(0,0,0,0.5)"; targetCtx.shadowBlur = 20; targetCtx.shadowOffsetY = 5; }
            targetCtx.clip();
            
            if (state.filterMode === 1) targetCtx.filter = 'contrast(1.1) saturate(1.1)';
            else if (state.filterMode === 2) targetCtx.filter = 'brightness(1.05) blur(0.5px) saturate(1.05)';
            else targetCtx.filter = 'none';
            
            const vw = vCam.videoWidth, vh = vCam.videoHeight, min = Math.min(vw, vh);
            targetCtx.drawImage(vCam, (vw-min)/2, (vh-min)/2, min, min, x-r, y-r, size, size);
            
            targetCtx.filter = 'none';
            targetCtx.strokeStyle = "#fff"; targetCtx.lineWidth = 6; targetCtx.stroke();
            targetCtx.restore();
        }

        // --- äº¤äº’é€»è¾‘ ---
        const autoBtn = document.getElementById('autoMoveBtn');
        autoBtn.onclick = () => {
            state.autoMove = !state.autoMove;
            if(state.autoMove) {
                autoBtn.innerText = "ğŸ¬ è‡ªåŠ¨è¿é•œ: å¼€";
                autoBtn.classList.add('active');
                document.getElementById('statusTip').innerText = "ğŸ’¡ æ­£åœ¨è‡ªåŠ¨ç¼“åŠ¨ï¼Œè¯·ç›´æ¥æ“ä½œä½ çš„è½¯ä»¶å³å¯";
            } else {
                autoBtn.innerText = "ğŸ¬ è‡ªåŠ¨è¿é•œ: å…³";
                autoBtn.classList.remove('active');
                document.getElementById('statusTip').innerText = "ğŸ’¡ é™æ€æ¨¡å¼";
            }
        };

        // è§¦æ§æ¿æ‰‹åŠ¨å¹²é¢„ (å¯é€‰)
        const viewport = document.getElementById('viewport');
        viewport.addEventListener('wheel', (e) => {
            if(state.autoMove) return; // å¼€å¯è‡ªåŠ¨æ—¶ç¦ç”¨æ‰‹åŠ¨ï¼Œé˜²æ­¢å†²çª
            e.preventDefault();
            let newZoom = state.camera.zoom - (e.deltaY * 0.001);
            state.camera.zoom = Math.max(1.0, Math.min(newZoom, 2.0));
        }, { passive: false });

        const filterBtn = document.getElementById('filterBtn');
        filterBtn.onclick = () => {
            state.filterMode = (state.filterMode + 1) % 3;
            if(state.filterMode===0) filterBtn.innerText = "ğŸš« åŸå›¾";
            else if(state.filterMode===1) filterBtn.innerText = "âœ¨ è´¨æ„Ÿ";
            else filterBtn.innerText = "ğŸ‘ æŸ”å…‰";
        };

        const pipBtn = document.getElementById('pipBtn');
        const vPip = document.getElementById('vPip');
        pipBtn.onclick = async () => {
            if(document.pictureInPictureElement) document.exitPictureInPicture();
            else {
                if(!vPip.srcObject) { vPip.srcObject = pipCanvas.captureStream(30); await vPip.play(); }
                try { await vPip.requestPictureInPicture(); } catch(e) {}
            }
        };

        const recBtn = document.getElementById('recBtn');
        const stopBtn = document.getElementById('stopBtn');
        const cd = document.getElementById('countdown');
        recBtn.onclick = () => {
            let c = 3; cd.innerText = c; cd.classList.remove('hidden');
            const t = setInterval(() => {
                c--; if(c>0) cd.innerText = c; else { clearInterval(t); cd.classList.add('hidden'); startRec(); }
            }, 1000);
        };
        function startRec() {
            chunks = []; const stream = canvas.captureStream(60);
            // å¦‚æœæœ‰éŸ³é¢‘è½¨é“ï¼Œæ··åˆç³»ç»ŸéŸ³é¢‘å’Œéº¦å…‹é£å¹¶ä½œä¸ºå•ä¸ªéŸ³é¢‘è½¨åŠ å…¥åˆ°å½•åˆ¶æµä¸­
            const screenStream = document.getElementById('vScreen').srcObject;
            const camStream = document.getElementById('vCam').srcObject;
            const hasScreenAudio = screenStream && screenStream.getAudioTracks && screenStream.getAudioTracks().length;
            const hasCamAudio = camStream && camStream.getAudioTracks && camStream.getAudioTracks().length;
            if (hasScreenAudio || hasCamAudio) {
                try {
                    // reuse existing audioCtx if available (created during init)ï¼Œç¡®ä¿è¿™æ˜¯åœ¨ç”¨æˆ·äº¤äº’ä¸­åˆ›å»º
                    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const dest = audioCtx.createMediaStreamDestination();
                    if (hasCamAudio) audioCtx.createMediaStreamSource(camStream).connect(dest);
                    if (hasScreenAudio) audioCtx.createMediaStreamSource(screenStream).connect(dest);
                    // å°†æ··åˆåçš„å•éŸ³é¢‘è½¨åŠ å…¥åˆ° canvas çš„æ•è·æµä¸­
                    dest.stream.getAudioTracks().forEach(t => stream.addTrack(t));
                } catch (e) { console.warn('éŸ³é¢‘æ··åˆå¤±è´¥ï¼Œå°†å°è¯•ç›´æ¥æ·»åŠ å•è½¨ï¼š', e); }
            }
            let mime = 'video/webm;codecs=vp9'; if(MediaRecorder.isTypeSupported('video/mp4')) mime = 'video/mp4';
            recorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 8000000 });
            recorder.ondataavailable = e => { if(e.data.size) chunks.push(e.data); };
            recorder.onstop = () => {
                const blob = new Blob(chunks, {type: mime}); const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `AutoCine_${Date.now()}.${mime.includes('mp4')?'mp4':'webm'}`; a.click();
            };
            recorder.start(); state.recording = true;
            recBtn.disabled = true; recBtn.innerText = "ğŸ¥ å½•åˆ¶ä¸­..."; stopBtn.disabled = false;
        }
        stopBtn.onclick = () => {
            if(state.recording) { recorder.stop(); state.recording = false; recBtn.disabled = false; recBtn.innerText = "ğŸ”´ å½•åˆ¶"; stopBtn.disabled = true; }
        };
    </script>
</body>
</html>